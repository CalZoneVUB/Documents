\chapter{Software Test Plan}
\section{Inleiding}
Het systeem kan op verschilende manieren getest worden. 
Langs de ene kant zijn er tests voor onafhankelijke stukken code (Unittests), en langs de andere kant wordt de samenwerking van deze componenten getest (Integratietests). 
Daarnaast moet op vlak van GUI getest worden of de applicatie stabiel blijft in bepaalde scenario's, of bij foute input. 
Door middel van tests moet gegarandeerd worden dat het systeem werkt en voldoet aan de specificaties beschreven in het SRS\cite{srs}. 
Wanneer de programmeur code wenst te pushen naar de hoofdrepository moet deze eerst alle tests successvol uitvoeren. 
Wanneer voldoende tests zijn geschreven garandeert dit dat het systeem werkt zoals verwacht.

\section{Soorten tests}

\subsection{Unittests}
Unittests zijn tests die kleine, onafhankelijke stukken code testen. Code die door unittests getest wordt mag geen gebruik maken van externe bronnen, anders kan men niet nagaan of de fout in de te testen klasse/methode zit, of in de externe code.
Wanneer een klasse wordt afgewerkt (of een subset van zijn methoden) moet hiervoor reeks unittests worden geschreven. 
Deze tests moeten correctheid van een individueel component nagaan. 
Wanneer de klasse wordt aangepast kunnen deze tests opnieuw gerunt worden. Hierdoor kunnen mogelijke problemen vroeg gedetecteerd worden.
Deze tests bevatten o.a. ook tests over de database, die vaak als een aparte categorie worden beschouwd. 

\subsection{Integratietests}
Bij unittests werd vermeld dat de klassen geen gebruik mogen maken van externe bronnen. Wanneer dit wel zo is, en dus de samenwerking tussen de twee componenten wordt getest, zijn dit integratietests, m.a.w. hoe twee of meer componenten met elkaar integreren. 
Gewoonlijk vangen integratietests meer bugs en regressies dan unittests, daarom moet de programmeur extra aandacht besteden aan het schrijven van dit soort tests.

\subsection{Verificatietests}
Verificatietests testen en garanderen dat het systeem voldoet aan de requirements beschreven in het SRS\cite{srs}. 
Deze tests zijn niet mutueel exclusief met unittests en integratietests, maar zijn in sommige gevallen wel expliciet nodig.

\subsection{GUI tests}
De GUI wordt ook uitvoerig getest. Deze moet blijven werken zoals verwacht met arbitraire input. Deze tests worden eveneens geautomatiseerd.

\section{Tools}
Door middel van JUnit 4\cite{junit} worden tests opgesteld voor het project. 
JUnit is een standaard Java library en overigens geïntegreerd in de user interface van Eclipse, waardoor het uitvoeren van tests makkelijk wordt en zodat men makkelijk conclusies kan trekken nadat alle tests gerunt zijn. 
Met JUnit kunnen makkelijk tests geschreven worden d.m.v. ``assertions''. 
Een assertion test of een echte waarde (verkregen door het uitvoeren van een methode) gelijk is aan de verwachte waarde opgegeven door de programmeur. Wanneer dit het geval is faalt de test. 	

\section{Criteria voor succesvolle tests}
Wanneer er geen fouten gevonden worden in een klasse d.m.v. de bijhorende tests zeggen we dat deze slaagt. 
Indien er zich wel fouten voordoen moeten deze worden opgelost alvorens de code mag worden opgenomen in de hoofdrepository.
De programmeur die een fout opmerkt maakt steeds een issue aan op GitHub indien hij zelf niet verantwoordelijk is voor de falende code.
Deze bug reports worden toegewezen aan de verantwoordelijke voor de falende code, welke de code zo snel mogelijk moet verbeteren. 
Wanneer een test faalt in onverwachte omstandigheden, m.a.w. in code die de programmeur niet heeft aangepast maar eventueel wel gebruikt, moet hiervoor ook een issue geplaatst worden op GitHub.

\noindent
Deze issue bevat de volgende informatie:
\begin{itemize}
	\item Het requirement ID, zoals gespecifieerd in het SRS\cite{srs}
	\item Een beschrijving van het probleem
	\item Input die het probleem veroorzaakt
	\item De verwachte output
	\item De daadwerkelijke output
\end{itemize}

Deze issue kan daarna opgelost worden door de programmeur verantwoordelijk voor de falende code, of door bijdrage van andere programmeurs.

\section{Verantwoordelijkheden}
De programmeur is verantwoordelijk voor het schrijven van tests voor zijn afgewerkte onderdelen. Code waar geen tests voor geschreven zijn mag niet worden opgenomen in de hoofdrepository op GitHub. Zonder tests kan de werking van deze code eenmaal niet worden bevestigd. De Software Quality Assurance Manager is verantwoordelijk voor het controleren dat de programmeurs deze tests volledig en correct schrijven.

\section{Indeling}
Alle tests worden bijgehouden in een aparte source folder in het project, genaamd \emph{src/main/tests}.
De directorystructuur in deze folder is dezelfde als die van de source code van het project.
Bronbestanden zijn georganiseerd in packages, en dat is met tests exact hetzelfde.
De java bronbestanden krijgen het \emph{Tests} suffix.

\noindent
Het project is op deze manier ingedeeld voor source folder \emph{src/main/java}
\begin{itemize}
	\item \textbf{com.vub.controller}: Hierin zitten alle Spring controllers, m.a.w. de klassen die alle requests van de front-end webpagina's verwerken.
	\item \textbf{com.vub.datadump}: Bevat alle klassen die nodig zijn om de gegeven datadump in te laden in onze database.
	\item \textbf{com.vub.exception}: Bevat alle custom exceptions die gethrowed worden in onze code. 
	In plaats van \emph{null} values terug te geven uit methoden geven wij de voorkeur aan een exception, vermits een exception nooit ambigu kan zijn, terwijl de betekenis van een \emph{null}-waarde het gevolg kan zijn van veel factoren.
	\item \textbf{com.vub.model}: In het \emph{model-view-controller} patroon bevat het model alle data.
	In dit project bevat het model alle data uit de database, vermits deze modellen rechtstreeks op de database worden gemapt. 
	In de modellen zit geen business logic, d.w.z. dat hierin geen methoden staan die ingewikkelder zijn dat standaard getters en setters. 
	\item \textbf{com.vub.repository}: Zoals hierboven vermeld worden alle modellen rechtstreeks op de database gemapt.
	Om de link te vormen tussen de database en de modellen is een \emph{repository} nodig.
	Deze repository biedt standaard methoden voor alle CRUD operaties en zoeken van data in de database.
	
	\item \textbf{com.vub.scheduler}: Deze package bevat alles m.b.t. de scheduler
	\item \textbf{com.vub.service}: De modellen bevatten geen business logic, en de repositories verzorgen alleen de directe link naar de database. 
	De services vormen een abstractielaag boven de repositories en bevatten alle business logic m.b.t. de modellen.
	Dit zijn de klassen waarmee ontwikkelaars rechtstreeks mee in contact komen, terwijl de repositories voor hen volledig verborgen zijn.
	\item \textbf{com.vub.springconfig}: Deze package bevat eventuele klassen die aangemaakt zijn om Spring te configureren. 
	\item \textbf{com.vub.validators}: Op gebied van validatie in de user interface kunnen \emph{validators} aangemaakt worden. 
	Hiermee gaat input van gebruikers geldig of ongeldig verklaard worden. 
\end{itemize}
	
\section{Testing van onderdelen}
Niet alle onderdelen zijn even belangrijk om te testen. Neem bijvoorbeeld de modellen in \emph{com.vub.model}, deze bevatten alleen getters/setters, en zijn daarom oninteressant om tests op uit te voeren. De meest belangrijke onderdelen om te testen zijn de volgende:
\begin{itemize}
	\item \textbf{com.vub.scheduler}: De scheduler houdt zich aan bepaalde regels waaraan een planning moet voldoen. 
	Om te garanderen dat deze regels (constraints) correct werken kunnen deze onderworpen worden aan unittests.
	\item \textbf{com.vub.service}: De service-laag kan complexe operaties bevatten die werken op de modellen, dus deze operaties moeten uitvoerig getest worden.
	\item \textbf{com.vub.validators}: Input van gebruikers in de user-interface wordt gevalideerd d.m.v. deze validators, dus daarom is het belangrijk dat deze correct werken.
	Daarom moeten validators ook uitvoerig getest worden.
\end{itemize}
	
\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{img/dir.png}
\caption{Directorystructuur van testbestanden.}
\label{dirstruct}
\end{figure}

\section{Uitgevoerde tests}
In de applicatie worden verschillende tests uitgevoerd. In onderstaande tabel staan alle uitgevoerde tests. Testklasse duidt de klasse aan (.java bestand) in het project waarin de test wordt uitgevoerd, en testnaam is de naam van de test. In een testklasse kunnen meerdere tests bestaan. Onderdeel slaat op het onderdeel van de applicatie waar de test   zich mee bezig houdt. Dit wil zeggen opslag van data in de database, testen van regels in de scheduler, enz...


\begin{table}[htbp]
	\centering
	\caption{Tests in de applicatie}
	\begin{tabularx}{\textwidth}{|X|X|X|X|}
	    \hline
		\textbf{Testklasse} & \textbf{Testnaam} & \textbf{Onderdeel} & \textbf{Beschrijving} \\ \hline
		CourseServiceTest	& testCourseCreation & Database & Test het aanmaken van een Course in de database (correcte opslag van velden) \\ \hline
		KeyServicetest & testKeyCreation & Database & Tests m.b.t. aanmaken van keys in de database \\ \hline
		RoomServiceTest & testRoomCreation & Database & Test of een lokaal kan aangemaakt worden in de database \\ \hline
		UserServiceTest & testUserCreation & Database & Test of een user kan aangemaakt worden in de database \\ \hline
		UserServiceTest & testUserActivation & Activatie & Test of users successvol geactiveerd kunnen worden (alleen met een activatie-key) \\ \hline
		EmailValidatorTest & notRealEmail & Validatie & Test of foute e-mailadressen niet geaccepteerd worden \\ \hline
		EmailValidatorTest & notRealEmail2 & Validatie & Andere test op foute-email adressen \\ \hline
		EmailValidatorTest & realEmail & Validatie & Test of een echt e-mail wordt geaccepteerd \\ \hline
		SchedularTest & overlappingTeacherAgenda- Explicit & Schedular & Test of 4 vakken gescheduled kunnen worden zonder overlap (met dezelfde prof, in één lokaal) \\ \hline
		SchedularTest & overlappingTeacherAgenda- Implicit & Schedular & Test of 4 vakken gescheduled kunnen worden zonder overlap (in één lokaal) \\ \hline
		SchedularTest & simpleSchedulingWith- Teachers & Schedular & 4 vakken moeten gescheduled worden in 2 tijdslots met maar 2 lokalen \\ \hline
		SchedularTest & schedulingRangeTest & Schedular & 4 vakken moeten gescheduled worden in veel tijdslots met één lokaal \\ \hline
		SchedularTest & roomAllocationByCapacity & Schedular & Scheduling van vakken, rekeninghoudend met capaciteit van lokalen \\ \hline
		SchedularTest & preventAdjacentLectures- OfSameCourseComponent & Schedular & Zorg dat HOC en WPO voor één vak niet overlapt \\ \hline
		SchedularTest & noonBreak & Schedular & Zorg dat er altijd een uur middagpauze is \\ \hline
		SchedularTest & correctRoomType & Schedular & Test of een vak altijd in een correct lokaal gepland wordt (leslokaal/computer lokaal) \\ \hline
		SchedularTest & advancedScheduling & Schedular & Probeer een volledige week te schedulen \\ \hline
		
	\end{tabularx}
\end{table}

\section{Belangrijkste Java code conventies}
Ook bij het testen van de applicatie moeten de Java conventies gehanteerd worden. 
Hieronder staan de belangrijkste.
\subsection{Naming conventions}
	\subsubsection{Klassen \& interfaces}
		Gebruik simpele, maar beschrijvende namen (zelfstandige naamwoorden) die iets zeggen over de klasse. Elk zelfstandig woord in de klassenaam begint met een hoofdletter. Vermijd acroniemen, tenzij deze algemeen gebruikt worden (zoals URL en HTTP).
		\\ \\
		\emph{\textbf{class Course;}} \\
		\emph{\textbf{class ProfilePageController;}}
		
	\subsubsection{Methoden}
		Namen van methoden beginnen met werkwoord (en een lowercase letter), met hoofdletters voor elk volgend woord.
		Merk ook op dat in het geval van booleaanse waarden, de getters en setters steeds beginnen met is, bijvoorbeeld \emph{isProjectorEquipped} (m.b.t. projectors in een lokaal). 
		Dit in tegenstelling to het foute \emph{hasProjector}.
		\\ \\
		\emph{\textbf{run();}} \\
		\emph{\textbf{runTests();}} \\
		\emph{\textbf{runTestInBackground();}}
		
	\subsubsection{Variabelen}
		Variabelen beginnen met een lowercase letter, met opeenvolgende woorden gestart worden met een hoofdletter. 
		De naam van een variabele moet kort, maar toch beschrijvend zijn. 
		De namen van constante variabelen in een klasse zijn volledig uppercase, met opeenvolgende woorden gescheiden door een underscore.
		\\ \\		
		\emph{\textbf{float width;}} \\
		\emph{\textbf{float minWidth;}} \\
		\emph{\textbf{int MIN\_WIDTH $=$ 1;}} \\
		\emph{\textbf{boolean DEBUG $=$ false;}} \\
		
		Bovendien wordt ook één declaratie per lijn aangemoedigd, omdat dit het schrijven van commentaar kan aanmoedigen.
		\\ \\
		\emph{\textbf{float width, height;} // fout} \\
		\emph{\textbf{float width;} // Width of the bridge} \\
		\emph{\textbf{float height;} // Height of the bridge}
		

\subsection{Klasse en interface declaraties}
	\begin{itemize}
		\item{Bij aanroep van een methode, geen spatie tussen de methode naam en het openende haakje}
		\item{De open brace \"\{\" staat op dezelfde lijn als de naam van de declaratie}
		\item{De sluitende brace staat automatisch op een nieuwe regel, tenzij de methode een lege body heeft}
		\item{Methoden zijn gescheiden door een blanke regel}
	\end{itemize}
